import subprocess
from pynput.keyboard import Key, Controller

# Define the command to start the Nios II Terminal
cmd = "nios2-terminal"

# Use subprocess to start the Nios II Terminal as a subprocess
process = subprocess.Popen(
    cmd, 
    stdout=subprocess.PIPE, 
    stderr=subprocess.PIPE
)

keyboard = Controller()
""" What is Controller()?

Controller() is a class from the pynput.keyboard module. It represents a virtual keyboard controller that allows you to simulate keyboard input programmatically.

By creating an instance of the Controller class, you can use its methods, such as press() and release(), to simulate key presses and releases. These simulated key events can be used to interact with other applications or systems as if actual keys were being pressed on a physical keyboard.

In your code, the keyboard variable is an instance of the Controller class, which is used to simulate keyboard input based on certain conditions and values read from the subprocess output."""

""" So if I run this python file and open notepad, I should see stuff being typed?

Yes, if you run this Python script and then focus on Notepad (or any other text input field), you should see simulated keyboard input.

The script uses the pynput.keyboard.Controller class to simulate keyboard presses and releases. The keys that are pressed depend on the values read from the subprocess's standard output.

For example, if x_read is 1 and dPressed is 0, the script simulates pressing the 'd' key. If x_read is 2 and aPressed is 0, the script simulates pressing the 'a' key, and so on.

What do u mean "focus"?

"Focusing" on a window or application means bringing it to the foreground and making it the active target for keyboard input.

When you click on a window or select it in some way, it comes to the "focus" of the operating system. This means that any keyboard inputs you make will be sent to that window.

In the context of your Python script, if you run the script and then click on Notepad to bring it into focus, the simulated keyboard inputs generated by the pynput.keyboard.Controller object will be sent to Notepad. 

So, if the script simulates pressing the 'd' key, for example, a 'd' will appear in Notepad as if you had pressed the 'd' key on your physical keyboard while Notepad was in focus. """

# Initialize variables
x_read = None
y_read = None
wPressed = 0
aPressed = 0
sPressed = 0
dPressed = 0
wCooldown = 100
aCooldown = 100
sCooldown = 100
dCooldown = 100

# Read the output of the subprocess
while True:
    accelerometer_data = process.stdout.readline()
    """ what does the line output = process.stdout.readline() do?
    
    The line output = process.stdout.readline() reads a single line of output from the subprocess's standard output stream (stdout) and assigns it to the variable output.

    Here's how it works:

        - process.stdout refers to the standard output stream of the subprocess object, which represents the output of the subprocess.
        - readline() is a method that reads a single line from the stream. It reads characters from the stream until it encounters a newline character (\n) or reaches the end of the stream.
        - The line read from the stream is then assigned to the variable output.
    
    In the context of the code you provided, this line is used within a while loop to continuously read the output of the subprocess and process it further. Each iteration of the loop reads a new line of output and assigns it to the output variable for further processing."""
    if accelerometer_data == b'' and process.poll() is not None:
        """ what does the line output == b'' and process.poll() is not None do?
        
        The line output == b'' and process.poll() is not None is a conditional statement that checks two conditions using the logical operator and. Let's break it down:

            1. output == b'': This condition checks if the variable output is equal to an empty bytes object b''. The == operator is used to compare the values of output and b''. If they are equal, the condition evaluates to True; otherwise, it evaluates to False.

            2. process.poll() is not None: This condition checks if the poll() method of the process object is not None. The poll() method is used to check if a child process has terminated. If the process has terminated, the poll() method returns the exit status of the process. If the process is still running, it returns None. The is not None comparison checks if the return value of poll() is not None. If it is not None, the condition evaluates to True; otherwise, it evaluates to False.
            
        In summary, the line output == b'' and process.poll() is not None checks if the output variable is an empty bytes object and if the poll() method of the process object is not None. If both conditions are True, the expression evaluates to True."""
        break
    if accelerometer_data:
        output_string = accelerometer_data.decode("utf-8").strip()
        """ what does the line output_str = output.decode("utf-8").strip() do?
        
        The line output_str = output.decode("utf-8").strip() performs two operations on the output variable:

            1. output.decode("utf-8"): This part decodes the output variable from bytes to a string using the UTF-8 encoding. The decode() method is used to convert a sequence of bytes into a string, and "utf-8" specifies the encoding to be used. UTF-8 is a widely-used encoding that can represent characters from many different languages.

            2. .strip(): This part removes any leading or trailing whitespace characters from the string. The strip() method is used to eliminate whitespace characters such as spaces, tabs, and newlines from the **beginning and end** of a string. If no argument is provided to strip(), it removes all whitespace characters by default.

        By combining these two operations, output_str will contain the decoded string from output with any leading or trailing whitespace removed. This can be useful when working with input/output operations where the data is in byte form and needs to be converted to a string representation. """
        
        """ How do I know that the variable output is a byte object/contains bytes and not string?? 
        
        output is likely a bytes object because it's the result of calling readline() on process.stdout, which typically returns output in bytes when you're using the subprocess module in Python. """
        print(output_string)

        # Extract the x_read and y_read values from the output
        if "x_read" in output_string:
            """ what does the line if "x_read" in output_str do?
            
            The line if "x_read" in output_str is a conditional statement that checks if the substring "x_read" is present in the string output_str.

            In Python, the in keyword is used to check if a value is present in a sequence, such as a string. In this case, it is checking if the substring "x_read" is present in the output_str string."""
            
            # Extract the x_read value from the output
            x_read = int(output_string.split("\t")[0].split(":")[1].strip())

        if "y_read" in output_string: 
            y_read = int(output_string.split("\t")[1].split(":")[1].strip())

        # Simulate keyboard input
        if x_read == 1 and dPressed == 0: # D
                if aPressed == 1:
                    keyboard.release('a')
                    aPressed = 0
                dPressed = 1
                keyboard.press('d')
                print("d is pressed")
                aCooldown = 100
                dCooldown = 100
        elif x_read == 1 and dPressed == 1: # if D is already pressed
                if dCooldown == 0:
                    keyboard.press('d')
                    print("d is pressed")
                    dCooldown = 300
                else:
                    dCooldown = dCooldown - 1
                    
        """ What are the cooldowns for??
        
        This code doesn't directly control the time between key presses. Instead, it uses a form of rate limiting by decrementing the cooldown variables in each iteration of the while loop.

        The dCooldown variable is set to a certain value when the 'd' key is pressed. In each iteration of the while loop, dCooldown is decremented by 1. The 'd' key is only pressed again when dCooldown reaches 0.

        This means that the 'd' key won't be pressed again until a certain number of iterations have passed, effectively creating a cooldown period. The length of this period depends on how often the loop iterates. If the loop iterates very quickly, the cooldown period will be shorter. If the loop iterates slowly, the cooldown period will be longer.

        It's important to note that this doesn't directly translate to real time seconds, as the time it takes for the loop to iterate depends on the performance of the system and the complexity of the operations within the loop.

        If you need to control the time between key presses in terms of real time seconds, you would need to use a different approach, such as using a timer or delay function that pauses execution for a specified amount of time. """

        if x_read == 2 and aPressed == 0: # A
                if dPressed == 1:
                    keyboard.release('d')
                    dPressed = 0
                aPressed = 1
                keyboard.press('a')
                print("a is pressed")
                aCooldown = 100
                dCooldown = 100
        elif x_read == 2 and aPressed == 1: # if A is already pressed
                if aCooldown == 0:
                    keyboard.press('a')
                    print("a is pressed")
                    aCooldown = 300
                else:
                    aCooldown = aCooldown - 1

        if y_read == 1 and wPressed == 0: # W
                if sPressed == 1:
                    keyboard.release('s')
                    sPressed = 0
                wPressed = 1
                keyboard.press('w')
                print("w is pressed")
                wCooldown = 100
                sCooldown = 100
        elif y_read == 1 and wPressed == 1: # if W is already pressed
                if wCooldown == 0:
                    keyboard.press('w')
                    print("w is pressed")
                    wCooldown = 300
                else:
                    wCooldown = wCooldown - 1
                    
        if y_read == 2 and sPressed == 0: # S
                if wPressed == 1:
                    keyboard.release('s')
                    wPressed = 0
                sPressed = 1
                keyboard.press('s')
                print("s is pressed")
                wCooldown = 100
                sCooldown = 100
        elif y_read == 2 and sPressed == 1: # if S is already pressed
                if sCooldown == 0:
                    keyboard.press('s')
                    print("s is pressed")
                    sCooldown = 300
                else:
                    sCooldown = sCooldown - 1
 
        if x_read == 3 and y_read == 3: # Neutral
                if wPressed == 1:
                    keyboard.release('w')
                    wPressed = 0
                if aPressed == 1:
                    keyboard.release('a')
                    aPressed = 0
                if sPressed == 1:
                    keyboard.release('s')
                    sPressed = 0
                if dPressed == 1:
                    keyboard.release('d')
                    dPressed = 0
                wCooldown = 100
                aCooldown = 100
                sCooldown = 100
                dCooldown = 100
